// Code generated by mongowrapper. DO NOT EDIT.
package tests

import (
	"context"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
	"net/url"
	"os"
	"sync"
	"time"
)

type UserRepository interface {
	Ping() error
	FindOne(ctx context.Context, findQuery bson.M) (*User, error)
	Exists(ctx context.Context, findQuery bson.M) (bool, error)
	FindOneById(ctx context.Context, id string) (*User, error)
	ExistsById(ctx context.Context, id string) (bool, error)
	FindMany(ctx context.Context, findQuery bson.M, sort bson.D, skip, limit int64) (ArrayOfUser, error)
	InsertOne(ctx context.Context, record *User) (InsertedID primitive.ObjectID, err error)
	InsertMany(ctx context.Context, records ArrayOfUser) (InsertedID []primitive.ObjectID, err error)
	UpdateOne(ctx context.Context, findQuery, updateQuery bson.M) (matched bool, modified bool, err error)
	UpdateOneById(ctx context.Context, id string, updateQuery bson.M) (matched bool, modified bool, err error)
	UpdateOneFluent(ctx context.Context, findQuery bson.M, updater UserUpdater) (matched bool, modified bool, err error)
	UpdateOneByIdFluent(ctx context.Context, id string, updater UserUpdater) (matched bool, modified bool, err error)
	DeleteOne(ctx context.Context, findQuery bson.M) (isDeleted bool, err error)
	DeleteOneById(ctx context.Context, id string) (isDeleted bool, err error)
	DeleteMany(ctx context.Context, findQuery bson.M) (delete int64, err error)
	Watch(pipeline mongo.Pipeline, ch chan<- UserChangeEvent) error

	AggregateToUserView(ctx context.Context, pipeline mongo.Pipeline, limit int) ([]*UserView, error)
}

type ArrayOfUser []*User
type usersRepository struct {
	client *mongo.Client
	ctx    context.Context
	c      *mongo.Collection
}

func NewUserRepositoryDefault(ctx context.Context) UserRepository {

	cs := os.Getenv("MONGODB_CONNECTION_STRING")

	if cs == "" {
		cs = "mongodb://db1:31001,db2:31002/ipo?replicaSet=rs&readPreference=primaryPreferred"
	}

	client := newClient(ctx, cs)

	return &usersRepository{
		client: client,
		ctx:    ctx,
		c:      database.Collection("users"),
	}
}

func NewUserRepository(ctx context.Context, cs string) UserRepository {
	u, err := url.Parse(cs)
	if err != nil {
		panic(err)
	}
	client := newClient(ctx, u.String())
	return &usersRepository{
		client: client,
		ctx:    ctx,
		c:      database.Collection("users"),
	}
}

func (s *usersRepository) Ping() error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	return s.client.Ping(ctx, readpref.Primary())
}

func (s *usersRepository) FindMany(ctx context.Context, findQuery bson.M, sort bson.D, skip, limit int64) (ArrayOfUser, error) {
	opts := &options.FindOptions{}
	opts.SetLimit(limit)
	opts.SetSkip(skip)
	opts.SetSort(sort)

	if cursor, err := s.c.Find(ctx, findQuery, opts); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	} else {
		records := make(ArrayOfUser, 0, limit)
		for cursor.Next(ctx) {
			t := User{}
			err := cursor.Decode(&t)
			if err != nil {
				return records, err
			}
			records = append(records, &t)
		}
		return records, nil
	}
}

func (s *usersRepository) FindOne(ctx context.Context, findQuery bson.M) (*User, error) {
	var r User
	if err := s.c.FindOne(ctx, findQuery).Decode(&r); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return &r, nil
}

func (s *usersRepository) Exists(ctx context.Context, findQuery bson.M) (bool, error) {
	res := s.c.FindOne(ctx, findQuery)
	err := res.Err()
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func (s *usersRepository) FindOneById(ctx context.Context, id string) (*User, error) {
	prim, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	var r User
	if err := s.c.FindOne(ctx, bson.M{"_id": prim}).Decode(&r); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return &r, nil
}

func (s *usersRepository) ExistsById(ctx context.Context, id string) (bool, error) {
	prim, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return false, err
	}
	res := s.c.FindOne(ctx, bson.M{"_id": prim})
	err = res.Err()
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func (s *usersRepository) InsertOne(ctx context.Context, record *User) (InsertedID primitive.ObjectID, err error) {
	res, err := s.c.InsertOne(ctx, record)
	if err != nil {
		return primitive.ObjectID{}, err
	}
	return res.InsertedID.(primitive.ObjectID), err
}

func (s *usersRepository) InsertMany(ctx context.Context, records ArrayOfUser) (InsertedID []primitive.ObjectID, err error) {
	data := make([]interface{}, len(records))
	for i := range records {
		data[i] = records[i]
	}
	res, err := s.c.InsertMany(ctx, data)
	if err != nil {
		return []primitive.ObjectID{}, err
	}
	ids := make([]primitive.ObjectID, len(res.InsertedIDs))
	for i := range res.InsertedIDs {
		ids[i] = res.InsertedIDs[i].(primitive.ObjectID)
	}
	return ids, err
}

func (s *usersRepository) UpdateOne(ctx context.Context, findQuery, updateQuery bson.M) (matched bool, modified bool, err error) {
	if res, err := s.c.UpdateOne(ctx, findQuery, updateQuery); err != nil {
		return false, false, err
	} else {
		return res.MatchedCount > 0, res.ModifiedCount > 0, nil
	}
}

func (s *usersRepository) UpdateOneById(ctx context.Context, id string, updateQuery bson.M) (matched bool, modified bool, err error) {
	if bsonId, err := primitive.ObjectIDFromHex(id); err != nil {
		return false, false, err
	} else {
		if res, err := s.c.UpdateOne(ctx, bson.M{"_id": bsonId}, updateQuery); err != nil {
			return false, false, err
		} else {
			return res.MatchedCount > 0, res.ModifiedCount > 0, nil
		}
	}
}

func (s *usersRepository) UpdateOneFluent(ctx context.Context, findQuery bson.M, updater UserUpdater) (matched bool, modified bool, err error) {
	if res, err := s.c.UpdateOne(ctx, findQuery, updater.(*users_updater).compile()); err != nil {
		return false, false, err
	} else {
		return res.MatchedCount > 0, res.ModifiedCount > 0, nil
	}
}

func (s *usersRepository) UpdateOneByIdFluent(ctx context.Context, id string, updater UserUpdater) (matched bool, modified bool, err error) {
	if bsonId, err := primitive.ObjectIDFromHex(id); err != nil {
		return false, false, err
	} else {
		if res, err := s.c.UpdateOne(ctx, bson.M{"_id": bsonId}, updater.(*users_updater).compile()); err != nil {
			return false, false, err
		} else {
			return res.MatchedCount > 0, res.ModifiedCount > 0, nil
		}
	}
}

func (s *usersRepository) DeleteOne(ctx context.Context, findQuery bson.M) (isDeleted bool, err error) {
	res, err := s.c.DeleteOne(ctx, findQuery)
	if err != nil {
		return false, err
	}
	return res.DeletedCount > 0, nil
}

func (s *usersRepository) DeleteOneById(ctx context.Context, id string) (isDeleted bool, err error) {
	if bsonId, err := primitive.ObjectIDFromHex(id); err != nil {
		return false, err
	} else {
		res, err := s.c.DeleteOne(ctx, bson.M{"_id": bsonId})
		if err != nil {
			return false, err
		}
		return res.DeletedCount > 0, nil
	}
}

func (s *usersRepository) DeleteMany(ctx context.Context, findQuery bson.M) (delete int64, err error) {
	res, err := s.c.DeleteMany(ctx, findQuery)
	if err != nil {
		return 0, err
	}
	return res.DeletedCount, nil
}

func (s *usersRepository) Watch(pipeline mongo.Pipeline, ch chan<- UserChangeEvent) error {
	updateLookup := options.UpdateLookup
	opts1 := &options.ChangeStreamOptions{
		FullDocument: &updateLookup,
	}
	stream, err := s.c.Watch(s.ctx, pipeline, opts1)
	if err != nil {
		return err
	}
	var wg sync.WaitGroup
	go func() {
		wg.Add(1)
		defer wg.Done()
		for {
			select {
			case <-s.ctx.Done():
				return
			default:
				iterateUserChangeStream(s.ctx, stream, ch)
			}
		}
	}()
	wg.Wait()
	return nil
}

func iterateUserChangeStream(ctx context.Context, stream *mongo.ChangeStream, ch chan<- UserChangeEvent) {
	for stream.Next(ctx) {
		var data UserChangeEvent
		if err := stream.Decode(&data); err != nil {
			continue
		}
		ch <- data
	}
}

type UserChangeEvent struct {
	ID struct {
		Data string `bson:"_data"`
	} `bson:"_id"`
	OperationType string              `bson:"operationType"`
	ClusterTime   primitive.Timestamp `bson:"clusterTime"`
	FullDocument  *User               `bson:"fullDocument"`
	DocumentKey   struct {
		ID primitive.ObjectID `bson:"_id"`
	} `bson:"documentKey"`
	Ns struct {
		Db   string `bson:"db"`
		Coll string `bson:"coll"`
	} `bson:"ns"`
}

func (entity *User) GetId() primitive.ObjectID {
	return entity.Id
}

func (entities ArrayOfUser) AsIdAware() []IdAware {
	res := make([]IdAware, len(entities))
	for i, v := range entities {
		res[i] = v
	}
	return res
}

func (entities ArrayOfUser) AsLookupById() map[primitive.ObjectID]*User {
	ids := make(map[primitive.ObjectID]*User, len(entities))
	for _, e := range entities {
		ids[e.Id] = e
	}
	return ids
}

type UserUpdater interface {
	SetId(vId primitive.ObjectID) UserUpdater
	SetEmail(vEmail string) UserUpdater
	SetProfile(vProfile Profile) UserUpdater
	SetAddressCity(vCity string) UserUpdater
	SetFinIncome(vIncome int64) UserUpdater

	Changes() map[string]interface{}
}

type users_updater struct {
	updates bson.M
}

func NewUserUpdater() UserUpdater {
	return &users_updater{
		updates: bson.M{},
	}
}

func (u *users_updater) compile() bson.M {
	return bson.M{"$set": u.updates}
}

func (u *users_updater) Changes() map[string]interface{} {
	return u.updates
}

func (u *users_updater) SetId(vId primitive.ObjectID) UserUpdater {
	u.updates["_id"] = vId
	return u
}

func (u *users_updater) SetEmail(vEmail string) UserUpdater {
	u.updates["email"] = vEmail
	return u
}

func (u *users_updater) SetProfile(vProfile Profile) UserUpdater {
	u.updates["profile"] = vProfile
	return u
}

func (u *users_updater) SetAddressCity(vCity string) UserUpdater {
	u.updates["address.City"] = vCity
	return u
}

func (u *users_updater) SetFinIncome(vIncome int64) UserUpdater {
	u.updates["Fin.Income"] = vIncome
	return u
}
