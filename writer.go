package main

import (
	"fmt"
	"github.com/zhekaby/mongowrapper/parser"
	"os"
	"text/template"
)

type writer struct {
	Cs, CsVar, DbVar string
	*parser.Parser
	*parser.DataView
	addGitignore bool
}

func NewWriter(cs, csVar, dbVar string, p *parser.Parser, addGitignore bool) *writer {
	return &writer{Cs: cs, CsVar: csVar, DbVar: dbVar, Parser: p, addGitignore: addGitignore}
}

func (w *writer) Write() error {


	fn := fmt.Sprintf("%s/client.go", w.Dir)
	if err := w.writeClient(fn); err != nil {
		return err
	}
	for _, c := range w.Collections {
		w.DataView = c
		fn := fmt.Sprintf("%s/repository_%s.go", w.Dir, w.DataView.Name)
		if err := w.writeCollections(fn); err != nil {
			return err
		}
	}

	_ = os.Remove(fmt.Sprintf("%s/aggregation_funcs.go", w.Dir))
	if len(w.Aggregations) > 0 {
		if err := w.writeAggregations(); err != nil {
			return err
		}
	}

	if w.addGitignore {
		fnGitignore := fmt.Sprintf("%s/.gitignore", w.Dir)
		_ = os.Remove(fnGitignore)
		gitignore, err := os.Create(fnGitignore)
		if err != nil {
			return err
		}
		defer gitignore.Close()
		fmt.Fprintf(gitignore, "client.go\n")
		for _, c := range w.Collections {
			fmt.Fprintf(gitignore, fmt.Sprintf("repository_%s.go\n", c.Name))
		}
		fmt.Fprintf(gitignore, "aggregation_funcs.go\n")
	}

	return nil
}

func (w *writer) writeAggregations() error {
	f, err := os.Create(fmt.Sprintf("%s/aggregation_funcs.go", w.Dir))
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Printf("generating %s...", f.Name())
	fmt.Fprintf(f, "// Code generated by mongowrapper. DO NOT EDIT.\n")
	fmt.Fprintf(f, "package %s\n", w.PkgName)
	for _, str := range []string{writerAggregation} {
		tpl, err := template.New("queue").Parse(str)
		if err != nil {
			return err
		}
		err = template.Must(tpl, err).Execute(f, w)
		if err != nil {
			return err
		}
	}
	fmt.Println("done")
	return nil
}

func (w *writer) writeClient(fn string) error {
	f, err := os.Create(fn)
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Printf("generating %s...", f.Name())
	fmt.Fprintf(f, "// Code generated by mongowrapper. DO NOT EDIT.\n")
	fmt.Fprintf(f, "package %s\n", w.PkgName)
	tpl, err := template.New("queue").Parse(writerClient)
	if err != nil {
		return err
	}
	err = template.Must(tpl, err).Execute(f, w)
	if err != nil {
		return err
	}
	fmt.Println("done")
	return nil

}

func (w *writer) writeCollections(fn string) error {
	f, err := os.Create(fn)
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Printf("generating %s...", f.Name())
	fmt.Fprintf(f, "// Code generated by mongowrapper. DO NOT EDIT.\n")
	fmt.Fprintf(f, "package %s\n", w.PkgName)

	for _, str := range []string{writerIface, writerUpdater} {
		tpl, err := template.New("queue").Parse(str)
		if err != nil {
			return err
		}
		err = template.Must(tpl, err).Execute(f, w)
		if err != nil {
			return err
		}
	}

	fmt.Println("done")
	return nil
}
